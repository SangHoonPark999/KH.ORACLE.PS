--EMPLOYEES 이름과 직급을 출력하시오. [ELLEN 님의 직급은 매니저 입니다.]
SELECT first_name ||'님의 직급은'|| JOB_ID || '입니다.' AS MESSAGE FROM EMPLOYEES;
--EMPLOYEES 직급을 중복하지말고 출력하시오.
SELECT DISTINCT JOB_ID FROM employees;
SELECT JOB_ID, COUNT(*) 직급별카운트 FROM employees GROUP BY JOB_ID HAVING COUNT(*) >=20 ;
--NULL은 비교대상이 되지 않는다
SELECT EMLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;
--직급을 기준으로 내림차순 정렬, 연봉은 오름차순 2차 정렬 이상 처리된다.
SELECT JOB_ID, SALARY FROM EMPLOYEES ORDER BY JOB_ID DESC, SALARY ASC;


--가상테이블 => 진짜 테이블(인스턴스가 1개, 컬럼명 1개 있는 테이블)
SELECT 24+NULL+34 AS RESULT FROM departments;
DESC DUAL;
SELECT 24+35 AS RESULT FROM DUAL;

--GROUP BY : 2개이상이 나와야 그룹의 대상이 된다.
--부서별 총 급여를 구하시오.
--SELECT * FROM GROUP BY HAVING WHERE ORDER BY (ASC/DESC) LIMIT
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID HAVING SUM(SALARY) >= 50000 AND DEPARTMENT_ID =100;
SELECT * FROM EMPLOYEES;
--
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID FROM employees
WHERE JOB_ID = UPPER('it_prog');
--CONCAT(인수가 2개만 허용된다.)
SELECT CONCAT(FIRST_NAME, '($'||SALARY||')') AS "사원정보" FROM EMPLOYEES
WHERE department_id = 30;
SELECT CONCAT(FIRST_NAME, '($',SALARY,')') AS "사원 정보" FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

SELECT FIRST_NAME, SUBSTR(HIRE_DATE,4,2)
FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--현재 날짜를 출력
SELECT SYSDATE FROM DUAL;
--EMPLOYEES에서 사원의 입사년도부터 현재까지 근무 개월수 올림 반올림등(TRUNC, ROUND)
SELECT FIRST_NAME, SYSDATE, TO_CHAR(HIRE_DATE,'YYYY/MM/DD') 입사일,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

--현제날짜에 '2024/04/24' 날짜를 뺴서 계산
SELECT SYSDATE-'2024/04/24' FROM DUAL;
SELECT SYSDATE- TO_DATE('2024/04/24','YYYY,MM,DD') FROM DUAL;
--문자열 + 문자열 => 오류
SELECT CONCAT('10000','20000') FROM DUAL;
SELECT TO_NUMBER('10,000','999,999') + TO_NUMBER('20,000','999,999') AS "합산" FROM DUAL;
-- EMPLOYEES 에서 직급별 정렬(오름차순), 이름, 봉급, 인상률, 보너스금액, 월급 + 보너스 금액
SELECT FIRST_NAME, SALARY, NVL(COMMISSION_PCT,0), SALARY*NVL(COMMISSION_PCT,0) AS COMMISSION, SALARY+(NVL(COMMISSION_PCT,0)) AS TOTAL
, JOB_ID FROM EMPLOYEES ORDER BY JOB_ID;
--NVL2(컬럼,  NULL이 아니면, NULL)
SELECT FIRST_NAME, SALARY, COMMISSION_PCT,
NVL2(COMMISSION_PCT,SALARY+(NVL(COMMISSION_PCT), SALARY) TOTAL_SAL FROM EMPLOYEES;
--SWITCH->DECODE
SELECT DEPARTMENT_ID,
DECODE(DEPARTMENT_ID,
10, 'Administration',
20, 'Marketing',
30, 'Purchasing',
40, 'Human Resources',
50, 'Shipping',
60, 'IT',
'DEFAULT' ) AS DEPARTMENTS FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

--GROUP BY SUM, AVG, MAX, MIN, COUNT
--COUNT(*) NULL 값은 인정하지 않는다.
SELECT COUNT(*) AS TOTAL FROM EMPLOYEES;
SELECT COUNT(SALARY) AS TOTAL FROM EMPLOYEES;
--부서별로 월급 평균을 구하시오
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS "부서별 평균 연봉", MAX(SALARY), MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
--EMPLOYEES 에서 부서별로 최대급여, 최소급여를 보여주되, 부서별 정렬(ASC)
SELECT DEPARTMENT_ID,MAX(SALARY),MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID;
--ROLLUP은 GROUP BY를 부분 항목별로 통계를 해줄것이다
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID,JOB_ID;
--CUBE ROLLUP 합계
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID;

--새로운 테이블 만들기 DEPT 속성(DEPTNO, DNAME, LOC) NOT NULL(모두), PK (DEPTNO)
CREATE TABLE DEPT(
    DEPTNO NUMBER(4),
    DNAME VARCHAR2(20) NOT NULL,
    LOC VARCHAR2(20) 
);
--PK생성
ALTER TABLE DEPT ADD CONSTRAINT DEPT_PK PRIMARY KEY(DEPTNO);
--PK드랍
ALTER TABLE DEPT DROP CONSTRAINT DEPT_PK;
ALTER TABLE DEPT MODIFY DNAME VARCHAR2(20);
ALTER TABLE DEPT ADD DPHONE VARCHAR2(12);
ALTER TABLE DEPT DROP COLUMN DPHONE;
ALTER TABLE DEPT DROP COLUMN LOC;
ALTER TABLE DEPT ADD LOC VARCHAR2(20) NULL;
--INSERT
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(1,'컴푸터학과','본관');
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(2,'시수템학과','공학관');
INSERT INTO DEPT VALUES(3,'컴공','공학관2');
INSERT INTO DEPT(DEPTNO, DNAME) VALUES(4,'디자인');
INSERT INTO DEPT VALUES(5,'컴디',NULL);
--SELECT
SELECT * FROM DEPT;
DESC DEPT;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
DROP TABLE DEPT;
SELECT * FROM DEPARTMENTS;
--기존의 테이블에 데이터만 다른 테이블에 있는 내용을 가져오고 싶을떄
INSERT INTO DEPT
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS;

SELECT * FROM DEPT;

UPDATE INTO table_name
SET column_name1 = value1, column_name2 = value2
WHERE conditions;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
--제약조건은 복사를 못한다.(ALTER TABLE을 사용해 제약조건을 넣어준다.)
CREATE TABLE EMP
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP;
DESC EMP;
-- EMP EMPLOYEE_ID PK 지정
ALTER TABLE EMP ADD CONSTRAINT EMPLOYEE_PK PRIMARY KEY(EMPLOYEE_ID);

--EMP 부서번호 90 => 91번으로 변경
UPDATE EMP SET DEPARTMENT_ID = 91; --X
ROLLBACK;
UPDATE EMP SET DEPARTMENT_ID = 91 WHERE DEPARTMENT_ID = 90;
COMMIT;
--EMP에서 부서 91만 SALARY 10%인상
UPDATE EMP SET SALARY = ROUND(SALARY*1.1) WHERE DEPARTMENT_ID = 91;
SELECT * FROM EMP WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP 에서 사원이름 SUSAN 사람의 부서를 20, 직급 FI_MGR
UPDATE EMP SET DEPARTMENT_ID = 20, JOB_ID = 'FI_MGR' WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP에서 부서 20번 직원만 삭제
DELETE FROM EMP WHERE DEPARTMENT_ID = 20;

--ROWID, ROWNIM 테이블의 행, ROW, INSTANCE, TUPLE 라인 번호를 자동설정한다
SELECT * FROM EMPLOYEES WHERE ROWNUM <= 3;
SELECT ROWID FROM EMPLOYEES;
SELECT ROWNUM FROM EMPLOYEES;
--TAB : TABLE 각 데이터베이스마냥 테이블 내용을 보고싶으면 TAB 조사하면 된다.
SELECT *FROM TAB;
--테이블 복사 : EMPLOYEES2 : EMPLOYEES (NOT NULL 제약조건)
--PK, UK, CHECK, FK(무결성제약조건 복사 이루어진다)
CREATE TABLE EMPLOYEES2
AS
SELECT * FROM EMPLOYEES;
DESC EMPLOYEES2;
--AGE 숫자 3 까지만 인정, 체크제약조건 0<나이<150
ALTER TABLE EMPLOYEES2
ADD AGE NUMBER(3) CHECK (AGE BETWEEN 0 AND 150);
--AGE 숫자 4 까지 증가
ALTER TABLE EMPLOYEES2 MODIFY AGE NUMBER(4);
--AGE 를 삭제해보세요
ALTER TABLE EMPLOYEES2 DROP COLUMN AGE;
-- FIRST_NAME VARCHAR2(20)=> VARCHAR2(10)
ALTER TABLE EMPLOYEES2 MODIFY FIRST_NAME VARCHAR2(22);
--EMPLOYEES2 테이블 삭제하고 ROLLBACK을 사용하지 않고 복구하는 방법
DROP TABLE EMPLOYEES2;
SELECT * FROM TAB;
--휴지통 구조
DESC RECYCLEBIN;
SELECT * FROM RECYCLEBIN;
--휴지통으로 복구
FLASHBACK TABLE EMPLOYEES2 TO BEFORE DROP;
--휴지통 비우기
PURGE RECYCLEBIN;

--컬럼사이즈를 줄여서 복사하는 방법
DROP TABLE TESTA;
CREATE TABLE TESTA(
    NAME CHAR(20) NOT NULL,
    AGE NUMBER(3) NOT NULL
);
INSERT INTO TESTA VALUES('1234567890',34);
INSERT INTO TESTA VALUES('12345678',60);
SELECT * FROM TESTA;
CREATE TABLE TESTB(
    NAME2 CHAR(10) NOT NULL,
    AGE2 NUMBER(3) NOT NULL
);
DESC TESTB;

INSERT INTO TESTB(NAME2,AGE2)
SELECT SUBSTR(NAME,1,10), AGE FROM TESTA;

SELECT * FROM TESTB;
--테이블 명을 변경하는 방법
SELECT *FROM TAB;
RENAME EMLOYEES2 TO EMPLOYEES4;


--테이블 설계한다. (EMO01, 번호, 직업, 부서) 제약조건은 NULL 허용
CREATE TABLE EMP02(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10),
    DEP_ID VARCHAR2(10)
);
INSERT INTO EMP02 VALUES (10, 'JDK','IT_TEACHER','NULL');
SELECT * FROM EMP02;
--DEP_ID NOT NULL 제약조건
TRUNCATE TABLE EMP02;
ALTER TABLE EMP02 MODIFY DEP_ID VARCHAR(10) NOT NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP02';

INSERT INTO EMP02(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
INSERT INTO EMP02 VALUES (12, 'KKK', 'ITDEV','LG');
--UNIQUE 제약조건을 줄것 (EMP_NAME)
DROP TABLE EMP05;
CREATE TABLE EMP05(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10) DEFAULT 'BACKEND',
    DEP_ID VARCHAR2(10)
);
ALTER TABLE EMP05 ADD CONSTRAINT EMP05_UK UNIQUE(EMP_NAME); 

ALTER TABLE EMP05
DROP CONSTRAINT SYS_C008426;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP05';
--UNIQUE 제약조건에 위배되는 조건
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
SELECT * FROM EMP05;
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (12, NULL, 'ITDEV','구글');
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (13, NULL, 'ITDEV','구글');

--데이터 DICTIONARY (USER, ALL, DBA) 제약조건 구조와 
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'EMPLOYEES';

-- DEPT1 테이블 생성 및 데이터 입력
-- 부모테이블에서 참조된 기본키 값을 변경하거나 삭제를 진행 할 때는
-- 자식테이블에 참조키를 NULL 수정하거나, 해당된 튜플을 삭제하면 된다.
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    CONSTRAINT DEPT01_PK PRIMARY KEY(DEPTNO)
);
INSERT INTO DEPT01 VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT01 VALUES(20,'RESEARCH','DALLAS');
INSERT INTO DEPT01 VALUES(30,'DEVELOPMENT','KOREA');
SELECT * FROM DEPT01;
DELETE FROM DEPT01 WHERE DEPTNO = 10;
UPDATE DEPT01 SET DEPTNO = 40 WHERE DEPTNO = 10;


--EMP01 테이블 생성 및 데이터 입력 UPDATE 할 때 없는 부모키를 참조하면 오류가 나올때를
--제외하면 문제가 없다 
CREATE TABLE EMP01(
    EMPNO NUMBER(4), --제약조건1(PK)
    ENAME VARCHAR2(10) NOT NULL, --제약조건2(NN)
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4), --제약조건3(FK) : 참조테이블 주의 UPDATE, DELETE
    PRIMARY KEY(EMPNO),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
);
INSERT INTO EMP01 VALUES(7499, 'ALLEN', 'SALESMAN', 10);
INSERT INTO EMP01 VALUES(7369, 'SMITH', 'CLERK', 20); 
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';
ALTER TABLE EMP01 DROP CONSTRAINT SYS_C008446;
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_DEPT01_DEPTNO_FK
FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO) ON DELETE CASCADE; 

SELECT * FROM EMP01;
DELETE FROM EMP01 WHERE EMPNO = 7499;
UPDATE EMP01 SET DEPTNO = 10 WHERE EMPNO = 7369;
DELETE FROM EMP01;
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';








