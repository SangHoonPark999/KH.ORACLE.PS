--EMPLOYEES 이름과 직급을 출력하시오. [ELLEN 님의 직급은 매니저 입니다.]
SELECT first_name ||'님의 직급은'|| JOB_ID || '입니다.' AS MESSAGE FROM EMPLOYEES;
--EMPLOYEES 직급을 중복하지말고 출력하시오.
SELECT DISTINCT JOB_ID FROM employees;
SELECT JOB_ID, COUNT(*) 직급별카운트 FROM employees GROUP BY JOB_ID HAVING COUNT(*) >=20 ;
--NULL은 비교대상이 되지 않는다
SELECT EMLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;
--직급을 기준으로 내림차순 정렬, 연봉은 오름차순 2차 정렬 이상 처리된다.
SELECT JOB_ID, SALARY FROM EMPLOYEES ORDER BY JOB_ID DESC, SALARY ASC;


--가상테이블 => 진짜 테이블(인스턴스가 1개, 컬럼명 1개 있는 테이블)
SELECT 24+NULL+34 AS RESULT FROM departments;
DESC DUAL;
SELECT 24+35 AS RESULT FROM DUAL;

--GROUP BY : 2개이상이 나와야 그룹의 대상이 된다.
--부서별 총 급여를 구하시오.
--SELECT * FROM GROUP BY HAVING WHERE ORDER BY (ASC/DESC) LIMIT
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID HAVING SUM(SALARY) >= 50000 AND DEPARTMENT_ID =100;
SELECT * FROM EMPLOYEES;
--
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID FROM employees
WHERE JOB_ID = UPPER('it_prog');
--CONCAT(인수가 2개만 허용된다.)
SELECT CONCAT(FIRST_NAME, '($'||SALARY||')') AS "사원정보" FROM EMPLOYEES
WHERE department_id = 30;
SELECT CONCAT(FIRST_NAME, '($',SALARY,')') AS "사원 정보" FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

SELECT FIRST_NAME, SUBSTR(HIRE_DATE,4,2)
FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--현재 날짜를 출력
SELECT SYSDATE FROM DUAL;
--EMPLOYEES에서 사원의 입사년도부터 현재까지 근무 개월수 올림 반올림등(TRUNC, ROUND)
SELECT FIRST_NAME, SYSDATE, TO_CHAR(HIRE_DATE,'YYYY/MM/DD') 입사일,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

--현제날짜에 '2024/04/24' 날짜를 뺴서 계산
SELECT SYSDATE-'2024/04/24' FROM DUAL;
SELECT SYSDATE- TO_DATE('2024/04/24','YYYY,MM,DD') FROM DUAL;
--문자열 + 문자열 => 오류
SELECT CONCAT('10000','20000') FROM DUAL;
SELECT TO_NUMBER('10,000','999,999') + TO_NUMBER('20,000','999,999') AS "합산" FROM DUAL;
-- EMPLOYEES 에서 직급별 정렬(오름차순), 이름, 봉급, 인상률, 보너스금액, 월급 + 보너스 금액
SELECT FIRST_NAME, SALARY, NVL(COMMISSION_PCT,0), SALARY*NVL(COMMISSION_PCT,0) AS COMMISSION, SALARY+(NVL(COMMISSION_PCT,0)) AS TOTAL
, JOB_ID FROM EMPLOYEES ORDER BY JOB_ID;
--NVL2(컬럼,  NULL이 아니면, NULL)
SELECT FIRST_NAME, SALARY, COMMISSION_PCT,
NVL2(COMMISSION_PCT,SALARY+(NVL(COMMISSION_PCT), SALARY) TOTAL_SAL FROM EMPLOYEES;
--SWITCH->DECODE
SELECT DEPARTMENT_ID,
DECODE(DEPARTMENT_ID,
10, 'Administration',
20, 'Marketing',
30, 'Purchasing',
40, 'Human Resources',
50, 'Shipping',
60, 'IT',
'DEFAULT' ) AS DEPARTMENTS FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

--GROUP BY SUM, AVG, MAX, MIN, COUNT
--COUNT(*) NULL 값은 인정하지 않는다.
SELECT COUNT(*) AS TOTAL FROM EMPLOYEES;
SELECT COUNT(SALARY) AS TOTAL FROM EMPLOYEES;
--부서별로 월급 평균을 구하시오
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS "부서별 평균 연봉", MAX(SALARY), MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
--EMPLOYEES 에서 부서별로 최대급여, 최소급여를 보여주되, 부서별 정렬(ASC)
SELECT DEPARTMENT_ID,MAX(SALARY),MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID;
--ROLLUP은 GROUP BY를 부분 항목별로 통계를 해줄것이다
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID,JOB_ID;
--CUBE ROLLUP 합계
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID;

--새로운 테이블 만들기 DEPT 속성(DEPTNO, DNAME, LOC) NOT NULL(모두), PK (DEPTNO)
CREATE TABLE DEPT(
    DEPTNO NUMBER(4),
    DNAME VARCHAR2(20) NOT NULL,
    LOC VARCHAR2(20) 
);
--PK생성
ALTER TABLE DEPT ADD CONSTRAINT DEPT_PK PRIMARY KEY(DEPTNO);
--PK드랍
ALTER TABLE DEPT DROP CONSTRAINT DEPT_PK;
ALTER TABLE DEPT MODIFY DNAME VARCHAR2(20);
ALTER TABLE DEPT ADD DPHONE VARCHAR2(12);
ALTER TABLE DEPT DROP COLUMN DPHONE;
ALTER TABLE DEPT DROP COLUMN LOC;
ALTER TABLE DEPT ADD LOC VARCHAR2(20) NULL;
--INSERT
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(1,'컴푸터학과','본관');
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(2,'시수템학과','공학관');
INSERT INTO DEPT VALUES(3,'컴공','공학관2');
INSERT INTO DEPT(DEPTNO, DNAME) VALUES(4,'디자인');
INSERT INTO DEPT VALUES(5,'컴디',NULL);
--SELECT
SELECT * FROM DEPT;
DESC DEPT;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
DROP TABLE DEPT;
SELECT * FROM DEPARTMENTS;
--기존의 테이블에 데이터만 다른 테이블에 있는 내용을 가져오고 싶을떄
INSERT INTO DEPT
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS;

SELECT * FROM DEPT;

UPDATE INTO table_name
SET column_name1 = value1, column_name2 = value2
WHERE conditions;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
--제약조건은 복사를 못한다.(ALTER TABLE을 사용해 제약조건을 넣어준다.)
CREATE TABLE EMP
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP;
DESC EMP;
-- EMP EMPLOYEE_ID PK 지정
ALTER TABLE EMP ADD CONSTRAINT EMPLOYEE_PK PRIMARY KEY(EMPLOYEE_ID);

--EMP 부서번호 90 => 91번으로 변경
UPDATE EMP SET DEPARTMENT_ID = 91; --X
ROLLBACK;
UPDATE EMP SET DEPARTMENT_ID = 91 WHERE DEPARTMENT_ID = 90;
COMMIT;
--EMP에서 부서 91만 SALARY 10%인상
UPDATE EMP SET SALARY = ROUND(SALARY*1.1) WHERE DEPARTMENT_ID = 91;
SELECT * FROM EMP WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP 에서 사원이름 SUSAN 사람의 부서를 20, 직급 FI_MGR
UPDATE EMP SET DEPARTMENT_ID = 20, JOB_ID = 'FI_MGR' WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP에서 부서 20번 직원만 삭제
DELETE FROM EMP WHERE DEPARTMENT_ID = 20;

--ROWID, ROWNIM 테이블의 행, ROW, INSTANCE, TUPLE 라인 번호를 자동설정한다
SELECT * FROM EMPLOYEES WHERE ROWNUM <= 3;
SELECT ROWID FROM EMPLOYEES;
SELECT ROWNUM FROM EMPLOYEES;
--TAB : TABLE 각 데이터베이스마냥 테이블 내용을 보고싶으면 TAB 조사하면 된다.
SELECT *FROM TAB;
--테이블 복사 : EMPLOYEES2 : EMPLOYEES (NOT NULL 제약조건)
--PK, UK, CHECK, FK(무결성제약조건 복사 이루어진다)
CREATE TABLE EMPLOYEES2
AS
SELECT * FROM EMPLOYEES;
DESC EMPLOYEES2;
--AGE 숫자 3 까지만 인정, 체크제약조건 0<나이<150
ALTER TABLE EMPLOYEES2
ADD AGE NUMBER(3) CHECK (AGE BETWEEN 0 AND 150);
--AGE 숫자 4 까지 증가
ALTER TABLE EMPLOYEES2 MODIFY AGE NUMBER(4);
--AGE 를 삭제해보세요
ALTER TABLE EMPLOYEES2 DROP COLUMN AGE;
-- FIRST_NAME VARCHAR2(20)=> VARCHAR2(10)
ALTER TABLE EMPLOYEES2 MODIFY FIRST_NAME VARCHAR2(22);
--EMPLOYEES2 테이블 삭제하고 ROLLBACK을 사용하지 않고 복구하는 방법
DROP TABLE EMPLOYEES2;
SELECT * FROM TAB;
--휴지통 구조
DESC RECYCLEBIN;
SELECT * FROM RECYCLEBIN;
--휴지통으로 복구
FLASHBACK TABLE EMPLOYEES2 TO BEFORE DROP;
--휴지통 비우기
PURGE RECYCLEBIN;

--컬럼사이즈를 줄여서 복사하는 방법
DROP TABLE TESTA;
CREATE TABLE TESTA(
    NAME CHAR(20) NOT NULL,
    AGE NUMBER(3) NOT NULL
);
INSERT INTO TESTA VALUES('1234567890',34);
INSERT INTO TESTA VALUES('12345678',60);
SELECT * FROM TESTA;
CREATE TABLE TESTB(
    NAME2 CHAR(10) NOT NULL,
    AGE2 NUMBER(3) NOT NULL
);
DESC TESTB;

INSERT INTO TESTB(NAME2,AGE2)
SELECT SUBSTR(NAME,1,10), AGE FROM TESTA;

SELECT * FROM DEPARTMENTS;
--테이블 명을 변경하는 방법
SELECT *FROM TAB;
RENAME EMLOYEES2 TO EMPLOYEES4;


--테이블 설계한다. (EMO01, 번호, 직업, 부서) 제약조건은 NULL 허용
CREATE TABLE EMP02(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10),
    DEP_ID VARCHAR2(10)
);
INSERT INTO EMP02 VALUES (10, 'JDK','IT_TEACHER','NULL');
SELECT * FROM EMP02;
--DEP_ID NOT NULL 제약조건
TRUNCATE TABLE EMP02;
ALTER TABLE EMP02 MODIFY DEP_ID VARCHAR(10) NOT NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP02';

INSERT INTO EMP02(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
INSERT INTO EMP02 VALUES (12, 'KKK', 'ITDEV','LG');
--UNIQUE 제약조건을 줄것 (EMP_NAME)
DROP TABLE EMP05;
CREATE TABLE EMP05(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10) DEFAULT 'BACKEND',
    DEP_ID VARCHAR2(10)
);
ALTER TABLE EMP05 ADD CONSTRAINT EMP05_UK UNIQUE(EMP_NAME); 

ALTER TABLE EMP05
DROP CONSTRAINT SYS_C008426;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP05';
--UNIQUE 제약조건에 위배되는 조건
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
SELECT * FROM EMP05;
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (12, NULL, 'ITDEV','구글');
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (13, NULL, 'ITDEV','구글');

--데이터 DICTIONARY (USER, ALL, DBA) 제약조건 구조와 
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'EMPLOYEES';

-- DEPT1 테이블 생성 및 데이터 입력
-- 부모테이블에서 참조된 기본키 값을 변경하거나 삭제를 진행 할 때는
-- 자식테이블에 참조키를 NULL 수정하거나, 해당된 튜플을 삭제하면 된다.
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    CONSTRAINT DEPT01_PK PRIMARY KEY(DEPTNO)
);
INSERT INTO DEPT01 VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT01 VALUES(20,'RESEARCH','DALLAS');
INSERT INTO DEPT01 VALUES(30,'DEVELOPMENT','KOREA');
SELECT * FROM DEPT01;
DELETE FROM DEPT01 WHERE DEPTNO = 10;
UPDATE DEPT01 SET DEPTNO = 40 WHERE DEPTNO = 10;


--EMP01 테이블 생성 및 데이터 입력 UPDATE 할 때 없는 부모키를 참조하면 오류가 나올때를
--제외하면 문제가 없다 
CREATE TABLE EMP01(
    EMPNO NUMBER(4), --제약조건1(PK)
    ENAME VARCHAR2(10) NOT NULL, --제약조건2(NN)
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4), --제약조건3(FK) : 참조테이블 주의 UPDATE, DELETE
    PRIMARY KEY(EMPNO),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
);
INSERT INTO EMP01 VALUES(7499, 'ALLEN', 'SALESMAN', 10);
INSERT INTO EMP01 VALUES(7369, 'SMITH', 'CLERK', 20); 
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';
ALTER TABLE EMP01 DROP CONSTRAINT SYS_C008446;
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_DEPT01_DEPTNO_FK
FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO) ON DELETE CASCADE; 

SELECT * FROM EMP01;
DELETE FROM EMP01 WHERE EMPNO = 7499;
UPDATE EMP01 SET DEPTNO = 10 WHERE EMPNO = 7369;
DELETE FROM EMP01;
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';

--CROSS JOIN (가로로 생성)
SELECT * FROM EMPLOYEES; --107
SELECT * FROM DEPARTMENTS; --27
SELECT COUNT(*) FROM EMPLOYEES, DEPARTMENTS; --2889
-- CROSS JOIN (ANSI CROSS JOIN))
SELECT COUNT(*) FROM EMPLOYEES CROSS JOIN DEPARTMENTS; --2889

-- INNER JOIN (PK:부모,참조 = FK:자식,기본,주)
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI INNER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI INNER JOIN USING) 기본키와 참조키의 속성명이 같을 경우
-- ON을 사용하지 말것, 별칭은 사용하되, USING으로 사용된 속성명에는 별칭을 붙이지 않는다.
SELECT E.FIRST_NAME, DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
USING(DEPARTMENT_ID)
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');

--NON EQUA JOIN 은 PK,FK가 없기에 '=' 연산자는 사용하지 않는다. 
CREATE TABLE SALARYGRADE (
    GRADE NUMBER,
    MINSALARY NUMBER,
    MAXSALARY NUMBER
);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(1, 2000, 3000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(2, 3001, 4500);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(3, 4501, 6000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(4, 6001, 8000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(5, 8001, 10000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(6, 10001, 13000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(7, 13001, 20000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(8, 20001, 30000);

SELECT E.FIRST_NAME, E.SALARY, S.GRADE 등급 FROM EMPLOYEES E, SALARYGRADE S
WHERE E.SALARY BETWEEN S.MINSALARY AND S.MAXSALARY;

--OUTER JOIN = INNER JOIN (PK, FK) = LEFT OUTER JOIN, RIGHT OUTER JOIN, BOTH OUTER JOIN
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
--OUTER JOIN (ANSI OUTER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--OUTER JOIN (ANSI OUTER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

--2007년도 상반기에 입사한 사원을 조사해라.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
AND (HIRE_DATE BETWEEN '2007.01.01' AND '2007.06.30');

--SELF JOIN (한개의 테이블을 두개 테이블로 만들어 조인한다)PK, 선언 되지 않는 FK 생각할것
SELECT * FROM EMPLOYEES;
SELECT E2.EMPLOYEE_ID, E2.FIRST_NAME 사원이름, E2.SALARY 사원월급, E1.EMPLOYEE_ID 상사아이디, E1.FIRST_NAME 상사이름, E1.SALARY 상사월급
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

SELECT E2.FIRST_NAME || '사원의 상사 이름은' || E1.FIRST_NAME || '입니다.'
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

--ROWNUM(번호가 자동설정진행) 10개만 보고 싶다.
SELECT * FROM EMPLOYEES WHERE ROWRUM<=10;
--SALARY 제일 많이 받는 사람순으로 10명만 출력
--연산의 순서가 다르기 때문에 서브쿼리를 사용하여 구한다.
SELECT * FROM EMPLOYEES ORDER BY SALARY DESC;
SELECT FIRST_NAME, SALARY FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC) WHERE ROWNUM <= 10;
--SUSAN 사원이 해당되는 사원의 사람이름, 부서번호, 부서명을 출력하시오
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');

--SUSAN, LEX 두사람의 급여 출력
SELECT FIRST_NAME, SALARY 
FROM EMPLOYEES 
WHERE FIRST_NAME IN ('Susan', 'Lex');
--EMPLOYEES 테이블에서 Susan 또는 Lex와 월급이 같은 직원의 이름, 업무, 급여를 출력하는 SELECT문을 
--작성하시오. (Susan, Lex는 제외) 
SELECT FIRST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES 
WHERE SALARY IN (
    SELECT FIRST_NAME, SALARY 
    FROM EMPLOYEES 
    WHERE FIRST_NAME IN ('Susan', 'Lex'))
AND NOT UPPER(FIRST_NAME) IN ('SUSAN','LEX'); 

--30번 소속 직원들 중에서 급여를 가장 많이 받은 사원 보다 더 많은 급여를 받는 사람의 이름, 급여 
--를 출력하는 쿼리문  작성
SELECT MAX(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30);

DROP TABLE EMP03;

CREATE TABLE EMP03
AS
SELECT * FROM EMPLOYEES WHERE 1 = 0;
SELECT * FROM EMP03;
DESC EMP03;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP03';
--DEPARTMENTS 구좀나 복사 DEPT01 => 내용을 추가한다.
DROP TABLE DEPT01 CASCADE CONSTRAINTS;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPARTMENTS
WHERE 1 = 0;
SELECT * FROM DEPT01;
INSERT INTO DEPT01 (SELECT * FROM DEPARTMENTS);

--10번 부서의 지역번호(1700)을 40번 부서의 지역번호(2400)으로 변경하기 위해서 서브 쿼리을 사용해본다.
SELECT * FROM DEPT01 WHERE DEPARTMENT_ID = 10;
SELECT * FROM DEPT01 WHERE DEPARTMENT_ID = 40;
UPDATE DEPT01 SET LOCATION_ID = 1700 WHERE DEPARTMENT_ID = 10;
UPDATE DEPT01 SET LOCATION_ID = (SELECT LOCATION_ID FROM DEPT01 WHERE DEPARTMENT_ID = 10) WHERE DEPARTMENT_ID = 40;

--TRANSATION TESTING
COMMIT; --트랜잭션이 끝남과 동시에 새로 트랜잭션이 새로 시작함.
DROP TABLE DEPT02;
CREATE TABLE DEPT02 --ROLLBACK 복구지점
AS
SELECT * FROM DEPARTMENTS;
SELECT * FROM DEPT02;
DELETE FROM DEPT02; --DROP, TRUNCATE, DELETE 차이점
SELECT * FROM DEPT02;
ROLLBACK;
SELECT * FROM DEPT02;
DELETE FROM DEPT02 WHERE DEPARTMENT_ID = 20;
SELECT * FROM DEPT02;
COMMIT; --
ROLLBACK;
SELECT * FROM DEPT02;

--VIEW
--VEIW IMP01 -VIEW 만들다 실제테이블(사원), 가상주체(사원아이다. 사원이름, 부서아이디)
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

CREATE VIEW VIEW_EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;
--DATA DICTIONARY (오라클에서 관리)
SELECT * FROM USER_TABLE;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
--가상부 내용 확인하기 없으면 가상뷰 새로 생성하기
SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME = 'VIEW_EMP01';
SELECT * FROM EMP01;
INSERT INTO EMP01
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID FROM EMPLOYEES
WHERE EMPLOYEE_ID =100;
CREATE OR REPLACE VIEW VIEW_EMP01
AS
SELECT * FROM EMP01;

SELECT * FROM VIEW_EMP01;
--가상뷰에 데이터를 입력
INSERT INTO VIEW_EMP01 VALUES (200,'PSH','IT_DEV', 80);
SELECT * FROM EMP01;
DELETE FROM VIEW_EMP01 WHERE EMPLOYEE_ID = 200;
--가상뷰 VIEW_SALARY 실제테이블 (부서별 총급여 합계, 전체평균금액, 인원수)
CREATE OR REPLACE VIEW VIEW_SALARY
AS
SELECT DEPARTMENT_ID, SUM(SALARY) TOTAL_SALARY, ROUND(AVG(SALARY),1) AVG_SALARY, COUNT(*) TOTAL_COUNT 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID ASC;
SELECT * FROM VIEW_SALARY;
SELECT * FROM VIEW_SALARY ORDER BY TOTAL_COUNT ASC;
-- EMPLOYEES, DEPARTMENTS 두개의 테이블을 JOIN(INNER JOIN)해서, 아이디, 이름, 부서아이디, 부서명 출력하되
-- 부서아이디 내림차순 정렬
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC;


CREATE OR REPLACE VIEW VIEW_EMP_DEPT
AS
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E , DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC;

SELECT * FROM VIEW_EMP_DEPT;

--VIEW FORCE TEST (구조는 만들어진다. 허나 조회, DESC, 사용하기 힘들다)
SELECT * FROM EMP15;

CREATE OR REPLACE FORCE VIEW VIEW_NOTABLE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP15;

SELECT * FROM USER_VIEWS;

SELECT * FROM VIEW_NOTABLE;
DESC VIEW_NOTABLE;

--VIEW WITH CHECK OPTION
SELECT * FROM EMP01;
INSERT INTO EMP01
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID != 100 AND DEPARTMENT_ID IS NOT NULL AND EMPLOYEE_ID != 200 AND EMPLOYEE_ID != 7499;

DESC EMP01;
ALTER TABLE EMP01 
MODIFY JOB VARCHAR2(20);
ALTER TABLE EMP01 
MODIFY EMPNO NUMBER(20);

--VIEW WITH CHECK OPTION TEST
--VIEW_CHK 만들고, 20번 부서에서 사원번호, 이름, 직급, 20번 부서번호 WITH CHECK OPTION 설정 (수정불가, 삭제 가능)
CREATE OR REPLACE VIEW VIEW_CHK
AS
SELECT EMP_NO, EMP_NAME, EMP_JOB, DEPARTMENT_ID
FROM EMP01
WHERE DEPARTMENT_ID = 20 WITH CHECK OPTION;

SELECT * FROM VIEW_CHK;
UPDATE VIEW_CHK SET DEP_ID = 30
WHERE EMP_NO = 201;

DELETE FROM VIEW_CHK WHERE DEP_ID = 20;

--VIEW WITH READ ONLY : 기본테이블의 어떤 컬럼에도 내용을 절대 변경할 수 없도록 설정한다.
--VIEW_READ 생성하고 EMP01에서 부서 30번을 ID, 이름, 직급, 부서ID
CREATE OR REPLACE VIEW VIEW_READ
AS
SELECT EMPNO, ENAME, JOB, DEPTNO 
FROM EMP01 
WHERE DEPTNO = 30
WITH READ ONLY;

SELECT * FROM VIEW_READ;
UPDATE VIEW_READ SET DEPTNO = 100 WHERE EMPNO = 114;
--ROWNUM 확인하기 (페이징 기법), ROWNUM은 테이블에 입력할 떄 결정된다.
SELECT * FROM EMPLOYEES;
SELECT ROWID, ROWNUM, FIRST_NAME FROM EMPLOYEES WHERE ROWNUM <= 20;
--ROWNUM 고용한 날짜 오래된순으로 10명만 
SELECT ROWNUM, FIRST_NAME, HIRE_DATE FROM EMPLOYEES
ORDER BY HIRE_DATE ASC;
--인라인 VIEW(TOP-N)
CREATE OR REPLACE VIEW VIEW_HIREDATE_ASC
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE;

SELECT ROWNUM, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE_ASC WHERE ROWNUM <= 10;

SELECT ROWNUM, FIRST_NAME, HIRE_DATE 
FROM (SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE)
WHERE ROWNUM <= 10;
--SEQUENCE 생성하기 EMP_SEQ 생성 시작값 1, 증가치 1, 최대값 무한대, 최소값 1, NOCYCLE, CACHE 2;
CREATE SEQUENCE EMP_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
NOMAXVALUE
NOCYCLE
CACHE 2;

DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY FROM EMPLOYEES WHERE 1 = 0;
SELECT * FROM EMP01;
DESC EMP01;
--SEQUENCE(AUTO INCREMENT) 사용하여 데이터를 입력하시오.
INSERT INTO EMP01 VALUES (EMP_SEQ.NEXTVAL, 'SH', SYSDATE, 40000); --사원번호 1증가
INSERT INTO EMP01 VALUES (EMP_SEQ.NEXTVAL, 'YG', SYSDATE, 30000);
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME FROM EMP01;
--SEQUENCE 현재 몇 번까지 번호가 설정되어 있는지 확인
SELECT EMP_SEQ.CURRVAL FROM DUAL;
--SEQUENCE 를 생성 DEV_SEQ, 시작값10, 증가치 10, 최소값 10, 최대값 20, N0CYCLE, CACHE 2
CREATE SEQUENCE DEV_SEQ
START WITH 10
INCREMENT BY 10
MINVALUE 10
MAXVALUE 30
NOCYCLE
CACHE 2;

--DEP01 테이블 생성
DROP TABLE DEP01;
CREATE TABLE DEP01
AS
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS WHERE 1 = 0;
--DEP01 DEP_SEQ 적용해서 입력을 하는데 오류발생
INSERT INTO DEP01 VALUES (DEV_SEQ.NEXTVAL, '행정',1);
INSERT INTO DEP01 VALUES (DEV_SEQ.NEXTVAL, '서무',2);
INSERT INTO DEP01 VALUES (DEV_SEQ.NEXTVAL, '총무',3);
INSERT INTO DEP01 VALUES (DEV_SEQ.NEXTVAL, '교육',4);
SELECT * FROM DEP01;
--DATA DICTIONARY 참조 SEQUENCE를
SELECT * FROM USER_SEQUENCES;
--DEV_SEQ 수정요청
ALTER SEQUENCE DEV_SEQ
MAXVALUE 100;

--인덱스 설정
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT * FROM EMPLOYEES;
SELECT * FROM EMP01;
--DATA DICTIONARY (오라클에서 DB에 관련된 정보를 관리하는 테이블)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';

SELECT * FROM EMP01 WHERE EMPLOYEE_ID = 200;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 200;
--EMP01 EMPLOYEE_ID 설정
CREATE UNIQUE INDEX IDX_EMP01_EMPLOYEE
IN EMP01(EMPLOYEE_ID);

--PL/SQL
DECLARE
    EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; --스칼라 변수, 레퍼런스 변수(객체참조변수)
    EMP_NAME EMPLOYEES.FIRST_NAME%TYPE;
BEGIN
    SELECT EMPLOYEE_ID, FIRST_NAME INTO EMP_ID, EMP_NAME FROM EMPLOYEES WHERE MANAGER_ID IS NULL;
    DBMS_OUTPUT.PUT_LINE('당신의 아이디는 '|| EMP_ID || ' 당신의 이름은 '|| EMP_NAME);
END;
/
DESC EMPLOYEES;

-- 테이블(배열) 타입정의해서 그것을 활용한다. (배열) String[] firstName;

DECLARE
    TYPE FIRST_NAME_TABLE_TYPE IS TABLE OF EMPLOYEES.FIRST_NAME%TYPE INDEX BY BINARY_INTEGER;
    TYPE JOB_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.JOB_ID%TYPE INDEX BY BINARY_INTEGER;
    TYPE EMPLOYEE_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.EMPLOYEE_ID%TYPE INDEX BY BINARY_INTEGER;
    TYPE MANAGER_ID_TABLE_TYPE IS TABLE OF EMPLOYEES.MANAGER_ID%TYPE INDEX BY BINARY_INTEGER;
    -- 변수(배열타입을 적용) 정수형 배열(1)
    NAME_TABLE FIRST_NAME_TABLE_TYPE;
    JOB_TABLE JOB_ID_TABLE_TYPE;
    EMPNO_TABLE EMPLOYEE_ID_TABLE_TYPE;
    MANAGER_TABLE MANAGER_ID_TABLE_TYPE;
    I BINARY_INTEGER :=0;
BEGIN
    FOR K IN (SELECT FIRST_NAME, JOB_ID, EMPLOYEE_ID, MANAGER_ID FROM EMPLOYEES) LOOP
        I := I + 1;
        NAME_TABLE(I) := K.FIRST_NAME;
        JOB_TABLE(I) := K.JOB_ID;
        EMPNO_TABLE(I) := K.EMPLOYEE_ID;
        MANAGER_TABLE(I) := K.MANAGER_ID;
        -- DBMS_OUTPUT.PUT_LINE('FIRST_NAME ' || K.FIRST_NAME  || ' JOB_ID '|| K.JOB_ID || 'EMP_NO ' || K.EMPLOYEE_ID);
    
    END LOOP;
    
    FOR J IN 1..I LOOP
        IF(MANAGER_TABLE(I) = '' OR MANAGER_TABLE(I) IS NULL) THEN
            MANAGER_TABLE(I)  :=0;
        END IF;
        DBMS_OUTPUT.PUT_LINE('1.FIRST_NAME = ' || NAME_TABLE(J)  || ' 2.JOB_ID = '|| JOB_TABLE(J) || '3.EMP_NO = ' || EMPNO_TABLE(J)|| ' 4.MANAGER_ID = ' || NVL(MANAGER_TABLE(J),0));
    
    END LOOP;
END;
/

-- RECORD TYPE 정의 CLASS 멤버변수 선택해서 하나의 타입으로 정의하는 것과 같다.
--ROWTYPE CLASS 모든 멤버변수를 선택해서 하나의 타입으로 정의 하는것과 같다.
DECLARE
    TYPE EMP_RECORD_TYPE IS RECORD(
        EMPLOYEE_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
        FIRST_NAME EMPLOYEES.FIRST_NAME%TYPE,
        JOB_ID EMPLOYEES.JOB_ID%TYPE,
        DEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE
    );
    -- 변수(배열타입을 적용) 정수형 배열(1)
    EMP_RECORD EMP_RECORD_TYPE;
    I BINARY_INTEGER :=0;
BEGIN
    FOR K IN (SELECT FIRST_NAME, JOB_ID, EMPLOYEE_ID, DEPARTMENT_ID FROM EMPLOYEES) LOOP
        EMP_RECORD.EMPLOYEE_ID := K.EMPLOYEE_ID;
        EMP_RECORD.FIRST_NAME := K.FIRST_NAME;
        EMP_RECORD.JOB_ID := K.JOB_ID;
        EMP_RECORD.DEPARTMENT_ID := K.DEPARTMENT_ID;
        DBMS_OUTPUT.PUT_LINE('1.FIRST_NAME = ' || EMP_RECORD.FIRST_NAME  || ' 2.JOB_ID = '|| EMP_RECORD.JOB_ID || 
        '3.EMP_NO = ' || EMP_RECORD.EMPLOYEE_ID|| ' 4.DEPARTMENT_ID = ' || EMP_RECORD.DEPARTMENT_ID);
    END LOOP;
END;
/
-- ROWTYPE 처리하기
--ROWTYPE CLASS 모든 멤버변수를 선택해서 하나의 타입으로 정의 하는것과 같다.
DECLARE
    EMP_RECORD EMPLOYEES%rowtype;
BEGIN
    SELECT * INTO EMP_RECORD FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'NEENA' ;
    DBMS_OUTPUT.PUT_LINE('사원번호 = ' || EMP_RECORD.FIRST_NAME);
END;
/

SELECT * FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'NEENA';

--IF THEN ELSE END IF;
--EMP에서 NEENA 정볼르 가져와서 인상률 체크해서 NULL이면 보너스를 뺀 연봉을 구해서 출력하고,
--인상률이 있으면 인상률을 연봉에 합산해서 출력하시오
DECLARE
    EMP_RECORD EMPLOYEES%rowtype;
    ANNSALARY NUMBER(10,2);
BEGIN
    
    SELECT * INTO EMP_RECORD FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = 'NEENA' ;
    IF (EMP_RECORD.COMMISSION_PCT IS NULL) THEN
        ANNSALARY := EMP_RECORD.SALARY * 12;
    ELSE
        ANNSALARY := EMP_RECORD.SALARY * 12 + (EMP_RECORD.SALARY * EMP_RECORD.COMMISSION_PCT);
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('사원번호 = ' || EMP_RECORD.FIRST_NAME || ' 연봉 = ' || ANNSALARY );
END;
/

--오라클에서 랜덤값 DBMS_RANDOM.VALUE(10,100) (CASTING)(MATH.RANDOM()*(큰값-작은값+1)+작은값)
SELECT CEIL(DBMS_RANDOM.VALUE(10,100)) FROM DUAL;
--문자 값을 임의의 랜덤값으로 구하기 BDMS_RANDOM.STRING('A',3)
SELECT DBMS_RANDOM.STRING('A',3) FROM DUAL;

-- 임의의 부서를 조회해서 첫번째 ROWNUM = 1 월급을 가져와서 출력하고, 1~5000 낮음, 5001~10000 중간
-- 10001~20000 최고, ~ 고연봉
DECLARE
    EMP_SALARY EMPLOYEES.SALARY%type;
    EMP_DEPNO EMPLOYEES.DEPARTMENT_ID%TYPE;
BEGIN
    EMP_DEPNO := ROUND(DBMS_RANDOM.VALUE(10,110),-1); -- ROUND(23.345,-1) : 20
    SELECT SALARY INTO EMP_SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = EMP_DEPNO AND ROWNUM <= 1;
    IF (EMP_SALARY BETWEEN 1 AND 5000) THEN
        DBMS_OUTPUT.PUT_LINE('월급 낮음');
    ELSIF (EMP_SALARY BETWEEN 5001 AND 10000) THEN
        DBMS_OUTPUT.PUT_LINE('월급 중간');
    ELSIF (EMP_SALARY BETWEEN 10001 AND 20000) THEN
        DBMS_OUTPUT.PUT_LINE('월급 높음');
    ELSE
        DBMS_OUTPUT.PUT_LINE('최고 수준');
    END IF;
    
    EXCEPTION
    WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(EMP_DEPNO||'부서번호가 존재하지 않습니다.');
END;
/

--랜덤으로 단수를 구해서 출력하는 프로그램을 작성하시오. DBMS_RANDOM.VALUE(1,21)
DECLARE
    DAN NUMBER;
    I NUMBER;
    TOTAL NUMBER;
BEGIN
    --랜덤값(1~21)
    DAN := ROUND(DBMS_RANDOM.VALUE(1,21));
    I := 0;
    --무한 루프
    LOOP
        I := I + 1;
        TOTAL := DAN * I;
        DBMS_OUTPUT.PUT_LINE(DAN || ' * ' || I || ' = ' || TOTAL);
     EXIT WHEN (I >= 9);
    END LOOP;
END;
/

SELECT * FROM DEPARTMENTS;
--CURSOR : ARRAYLIST<DEPARTMENTS> 부서정보를 모두 가져와서 출력하는 프로그램을 작성하시오. (단, CURSOR 사용할것)
DECLARE
    CURSOR DEPARTMENT_CURSOR IS SELECT * FROM DEPARTMENTS;
    VDEPT DEPARTMENTS%ROWTYPE;
BEGIN
    OPEN DEPARTMENT_CURSOR;
    
    LOOP
        FETCH DEPARTMENT_CURSOR INTO VDEPT.DEPARTMENT_ID, VDEPT.DEPARTMENT_NAME, VDEPT.MANAGER_ID, VDEPT.DEPARTMENT_LOCATION_iD ;
        
        EXIT WHEN DEPARTMENT_CURSOR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(VDEPT.DEPARTMENT_ID || ' , ' || DEPT.DEPARTMENT_NAM || ' , ' || VDEPT.MANAGER_ID || ',' || VDEPT.DEPARTMENT_LOCATION_iD);
    END LOOP;
    CLOSE DEPARTMENT_CURSOR;
END;
/
--샹상된포문
DECLARE
    야]]]DS/..T                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
BEGIN
    OPEN DEPARTMENT_CURSOR;
    
    LOOP
        FETCH DEPARTMENT_CURSOR INTO VDEPT.DEPARTMENT_ID, VDEPT.DEPARTMENT_NAME, VDEPT.MANAGER_ID, VDEPT.DEPARTMENT_LOCATION_iD ;
        
        EXIT WHEN DEPARTMENT_CURSOR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(VDEPT.DEPARTMENT_ID || ' , ' || DEPT.DEPARTMENT_NAM || ' , ' || VDEPT.MANAGER_ID || ',' || VDEPT.DEPARTMENT_LOCATION_iD);
    END LOOP;
    CLOSE DEPARTMENT_CURSOR;
END;
/

--저장 프로시처 = 함수 로 생각한다
CREATE OR REPLACE PROCEDURE EMP_PROSEDURE
IS
    --임의의 문자를 받는 변수선언
    VWORD VARCHAR2(1);
    --모든 레코드 타입을 받는 변수선언
    VEMP EMPLOYEES%ROWTYPE;
    --커서 = ARRAYLIST
    CURSOR C1 (VWORD VARCHAR2)
    IS
    SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, JOB_ID FROM EMPLOYEES WHERE FIRST_NAME LIKE '%||VWORD||%';

BEGIN
    -- 임의문자 추출하고, 출력
    VWORD := DBMS_RANDOM.STRING('a',1);
    DBMS_OUTPUT.PUT_LINE('랜덤 문자'|| VWORD);
    OPEN C1(VWORD);
    LOOP
        FETCH C1 INTO VEMP.EMPLOYEE_ID, VEMP.FIRST_NAME, VEMP.SALARY, VEMP.JOB_ID;
        -- C1ROWCOUNT CHECK
        IF C1%ROWCOUNT = 0 THEN
            DBMS_OUTPUT.PUT_LINE('해당인원이 없습니다.');
        END IF;
        EXIT WHEN C1%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('ID = '|| VEMP.EMPLOYEE_ID ||'FIRST_NAME = '|| VEMP.FIRST_NAME ||'SALARY = '|| VEMP.SALARY);
    END LOOP;
END;
/
SHOW ERROR;

EXECUTE EMP_PROSEDURE;
-- PROCEDURE 프로그램 코드 확인
SELECT * FROM USER_SOURCE;

--매개변수가 있는 PROCEDURE
CREATE OR REPLACE PROCEDURE EMP_PROCEDURE2(VWORD IN VARCHAR2)
IS
    VCOUNT NUMBER:=0; 
   -- 모든 레코드 타입을 받는 변수
   VEMP EMPLOYEES%ROWTYPE;
   -- 커서 = ARRAY LIST
   CURSOR C1
   IS
   SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
BEGIN
    DBMS_OUTPUT.PUT_LINE('입력된 문자' VWORD); 
    -- 먼저 데이터 유무 확인
   SELECT COUNT(*) INTO VCOUNT FROM EMPLOYEES WHERE FIRST_NAME LIKE '%'||VWORD||'%';
   IF VCOUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('데이터가 존재하지 않습니다.');
   ELSE
      -- 커서 FOR LOOP 사용 (더 안전하고 간단)
      FOR VEMP IN C1 LOOP
         DBMS_OUTPUT.PUT_LINE('ID='||VEMP.EMPLOYEE_ID||'FIRST_NAME='||VEMP.FIRST_NAME);
      END LOOP;
   END IF;
END;
/
SHOW ERROR;
EXECUTE EMP_PROSEDURE2('K');

-- DEPT01 새로운 부서를 프로시저를 이용해서 입력하고, 전체를 출력하는 프로그램을 작성하시오.
CREATE OR REPLACE PROCEDURE DEPT_INSERT(
    DEPT_NO IN DEPT01.DEPARTMENT_ID%TYPE,
    DEPT_NAME IN DEPT01.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER_ID IN DEPT01.MANAGER_ID%TYPE,
    DEPT_LOCATION IN DEPT01.LOCATION_ID%TYPE)
IS
BEGIN
    INSERT INTO DEPT01 VALUES(DEPT_NO, DEPT_NAME, DEPT_MANAGER_ID, DEPT_LOCATION);
    COMMIT;
    FOR VDEPT IN (SELECT * FROM DEPT01) LOOP
        DBMS_OUTPUT.PUT_LINE('ID = '|| VDEPT.DEPARTMENT_ID || 'NAME = '|| VDEPT.DEPARTMENT_NAME);
    END LOOP;
END;
/
EXECUTE DEPT_INSERT(290, 'IT_DEV',NULL,3000);
SELECT *FORM DEPT01;

--DEPT01 프로시저를 이용해서 새로운 부서내용을 입력하고자 한다.
--기존에 없는 부서이면 INSERT를 하고, 있는 부서이면 UPDATE를 하고, 해당된 부서를 출력하시오
CREATE OR REPLACE PROCEDURE DEPT_INSERT_UPDATE(
    DEPT_NO IN DEPT01.DEPARTMENT_ID%TYPE,
    DEPT_NAME IN DEPT01.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER_ID IN DEPT01.MANAGER_ID%TYPE,
    DEPT_LOCATION IN DEPT01.LOCATION_ID%TYPE)
IS
    VCOUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO VCOUNT FROM DEPT01 WHERE DEPARTMENT_ID = DEPT_NO;
    IF VCOUNT = 0  THEN
        INSERT INTO DEPT01 VALUES(DEPT_NO, DEPT_NAME, DEPT_MANAGER_ID, DEPT_LOCATION);
    ELSE
        UPDATE DEPT01 SET DEPARTMENT_NAME, MANAGER_ID = DEPT_MANAGER_ID, LOCATION_ID = DEPT_LOCATION
        WHERE DEPARTMENT_ID = DEPT_NO;
    END IF;
    COMMIT;
    
    INSERT INTO DEPT01 VALUES(DEPT_NO, DEPT_NAME, DEPT_MANAGER_ID, DEPT_LOCATION);
    COMMIT;
    FOR VDEPT IN (SELECT * FROM DEPT01) LOOP
        DBMS_OUTPUT.PUT_LINE('ID = ' VDEPT.DEPARTMENT_ID || 'NAME = '|| VDEPT.DEPARTMENT_NAME||
        'MANAGER = '|| VDEPT.MANAGER_ID || 'LOCATION = '|| VDEPT.LOCATION_ID);
    END LOOP;
END;
/


SELECT COUNT(*)  FROM DEPT01 WHERE DEPARTMENT_ID = 400;
EXECUTE DEPT_INSERT_UPDATE(500, 'IT_DEVELOPMENT',3000,15DWE000);

--EMPLOYEES 에서 해당아이디를 입력하면 이름, 월급, 근무내용을 리턴하는ㄴ 프로시접 작성
CREATE OR REPLACE PROCEDURE DEPT_OUTPUT(
    DEPT_NO IN DEPT01.DEPARTMENT_ID%TYPE,
    DEPT_NAME OUT DEPT01.DEPARTMENT_NAME%TYPE,
    DEPT_MANAGER_ID OUT DEPT01.MANAGER_ID%TYPE,
    DEPT_LOCATION OUT DEPT01.LOCATION_ID%TYPE)
IS
BEGIN
    SELECT DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID INTO DEPT_NAME, DEPT_MANAGER_ID, DEPT_LOCATION
    FROM DEPT01 WHERE DEPARTMENT_ID = DEPT_NO; 
END;
/

DECLARE
    VEMP DEPT01%ROWTYPE;
BEGIN
    DEPT_OUTPUT(20,VEMP.DEPARTMENT_NAME, VEMP.MANAGER_ID, VEMP.LOCATION_ID);
    DBMS_OUTPUT.PUT_LINE('ID = ' VEMP.DEPARTMENT_ID || 'NAME = '|| VEMP.DEPARTMENT_NAME||
        'MANAGER = '|| VEMP.MANAGER_ID || 'LOCATION = '|| VEMP.LOCATION_ID);
END;
/

--다른 방법으로 출력
VARIABLE NAME VARCHAR2(20)
VARIABLE MANAGER NUMBER
VARIABLE LOCATION NUMBER
EXECUTE DEPT_OUTPUT (20, :NAME, :MANAGER, :LOCATION);
PRINT NAME
PRINT MANAGER
PRINT LOCATION;

--IN OUT MODE 테스트하기
CREATE OR REPLACE PROCEDURE PROC_INOUTMODE (V_SAL IN OUT VARCHAR2)
IS BEGIN
V_SAL := '$' ||SUBSTR(V_SAL, -9, 3)||','||SUBSTR(V_SAL, -6, 3)||',' || SUBSTR(V_SAL, -3, 3);
END;
/

DECLARE
    STRNUM VARCHAR2(20) := '123456789';
BEGIN
    PROC_INOUTMODE (STRNUM);
    DBMS_OUTPUT.PUT_LINE('STRNUM = ' || STRNUM);
END;
/

--트리거에서 꼭 기억해야 될 것
--INSERT 입력된 컬럼값은 : NEW,
--DELETE 삭제되는 컬럼 : OLD,
--UPDATE 번경전 컬럼 : OLD 수정할 새로운 데이터 값 : NEW

SELECT * FROM EMP01;
DESC EMP01;
DROP TABLE EMP02;
CREATE TABLE EMP02(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(20),
    JOB VARCHAR2(50)
);
-- TRIGGER 설정 EMP02 테이블에 INSERT가 발생하면 입력되었단는 메세지를 출력
CREATE OR REPLACE TRIGGER EMP02_TRG01
AFTER INSERT ON EMP02
BEGIN
    DBMS_OUTPUT.PUT_LINE('신입사원이 입사하였습니다');
END;
/

INSERT INTO EMP02 VALUES(10, '개발부','연구원');
SELECT * FROM EMP02;


--EMP01에 신입사원이 등록이 되면, SAL01 신입사원 사원번호, 기본월급 2000000 TRIGGER 통해서 입력하시오
--SAL01.SALNO SEQUENCE NUMBER 자동으로 증가해서 등록하도록 프로그램
CREATE TABLE SAL01(
    SALNO NUMBER(4),
    SAL NUMBER,
    EMPNO NUMBER(4),
    CONSTRAINT SAL01_PK PRIMARY KEY(SALNO),
    CONSTRAINT SAL01_FK FOREIGN KEY(EMPNO) REFERENCES EMP01(EMPLOYEE_ID)
);

DROP SEQUENCE SAL01_SEQ;

CREATE SEQUENCE SAL01_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 1000
NOCYCLE
CACHE 2;

CREATE OR REPLACE TRIGGER EMP01_TRG02
AFTER INSERT ON EMP01
FOR EACH ROW
BEGIN
    INSERT INTO SAL01(SALNO, SAL, EMPNO)
    VALUES(SAL01_SEQ.NEXTVAL, 2000000, :NEW.EMPLOYEE_ID);
    DBMS_OUTPUT.PUT_LINE('신입사원이 입사해서 봉급테이블에 새로 등록했습니다.');
END;
/

INSERT INTO EMP01 VALUES (300,'DONG','KIM','KIM','650.502.4321','23/06/02','IT',2000,NULL,124,50);
INSERT INTO EMP01 VALUES (301,'FONG','KIM','KIM','650.502.4322','23/06/02','IT',2000,NULL,124,50);
INSERT INTO EMP01 VALUES (302,'GONG','KIM','KIM','650.502.4323','23/06/02','IT',2000,NULL,124,50);

SELECT *FROM SAL01;
--EMP01에서 사원번호 300,301 제거하면 SAL01에도 삭제가 진행이 되도록 트리거 프로그램작성
CREATE OR REPLACE TRIGGER EMP01_TRG03
AFTER DELETE ON EMP01
FOR EACH ROW
BEGIN
    DELETE FROM SAL01 WHERE EMPNO=:OLD.EMPLOYEE_ID;
    DBMS_OUTPUT.PUT_LINE(:OLD.EMPLOYEE_ID||'신입사원이 퇴사해서 봉급테이블에 삭제했습니다.');
END;
/

DELETE FROM EMP01 WHERE EMPLOYEE_ID = 300;
DELETE FROM EMP01 WHERE EMPLOYEE_ID = 301;

-- FUNCTION 프로그램 작성 부서번호값을 입력하면, DEP01 부서번호를 참조해서 부서명을 리턴해주는 함수를 작성하시오.
-- 해당된 부서번호가 없다면 '해당부서번호 없음' 을 리턴해주시오.
CREATE OR REPLACE FUNCTION GET_DEPART_NAME(VDEPT_NO IN EMPLOYEES.DEPARTMENT_ID%TYPE) RETURN VARCHAR2
IS
    VCOUNT NUMBER:=0;
    VDEPARTMENT_NAME VARCHAR2 (100);
BEGIN
    SELECT COUNT(*) INTO VCOUNT FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPT_NO;
    IF VCOUNT = 0 THEN
        VDEPARTMENT_NAME := '해당부서 없음';
    ELSE
        SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPT_NO;
    END IF;
    RETURN VDEPARTMENT_NAME;
END;
/

SELECT FIRST_NAME, JOB_ID, SALARY, DEPARTMENT_ID, GET_DEPART_NAME(DEPARTMENT_ID) AS 부서명
FROM EMPLOYEES WHERE FIRST_NAME = 'Steven';

SELECT GET_DEPART_NAME(300) FROM DUAL;

VARIABLE VDNAME VARCHAR2;
EXECUTE : VDNAME :=GET_DEPART_NAME(20);

--부서번호를 함수매개변수로 등록하여 해당부서의 평금 급여를 리턴하는 함수 작성
CREATE OR REPLACE FUNCTION GET_AVG_SALARY(VDEPT_NO IN EMPLOYEES.DEPARTMENT_ID%TYPE) RETURN VARCHAR2
IS
    VAVG VARCHAR2 (100);
BEGIN
    SELECT TO_CHAR(AVG(SALARY),'999,999,999') INTO VAVG_SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPT_NO;
    RETURN VAVG_SALARY;
    
    EXCETION
    WHEN NO_DATA_FOUND THEN
    VAVG_SALARY :='해당부서없음';
    RETURN VAVG_SALARY;
END;
/
SELECT GET_AVG_SALARY(20) FROM DUAL;
SELECT FIRST_NAME, JOB_ID, SALARY, DEPARTMENT_ID, GET_AVG_SALARY(DEPARTMENT_ID) AS 부서명
FROM EMPLOYEES WHERE FIRST_NAME = 'Steven';


--부서별로 월급 순위 구하기

SELECT DEPARTMENT_ID,  
    FIRST_NAME,  
    SALARY,  
    COMMISSION_PCT,  
    RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC, COMMISSION_PCT DESC) RANK  
FROM EMP01  
ORDER BY DEPARTMENT_ID, SALARY DESC, COMMISSION_PCT DESC;

-- 그룹별 최소값, 최대값 구하기 
SELECT DEPARTMENT_ID ,
    FIRST_NAME, 
    SALARY,   
    MIN(SALARY) KEEP(DENSE_RANK FIRST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID) SAL_MIN,  
    MAX(SALARY) KEEP(DENSE_RANK LAST ORDER BY SALARY) OVER(PARTITION BY DEPARTMENT_ID)  SAL_MAX  
FROM EMP01  
ORDER BY DEPARTMENT_ID, SALARY DESC;

-- 페이징 기법 입사한 날짜별로 정렬을 하되 한 페이지 당 10개씩 보여준다. 총 4페이지. (1:1~10, 2: 11~20..., 4: 31~40)
SELECT * FROM (SELECT ROWNUM AS RNUM, E.* FROM EMPLOYEES E ORDER BY HIRE_DATE ASC) WHERE RNUM BETWEEN 31 AND 40;
--정렬 기준컬럼과 페이징 마지막 번호와 시작페이지를 결정하면 된다. 아래의 쿼리문 정렬기준 : HIRE_DATE, PAGE 31~40
SELECT * 
FROM (SELECT ROWNUM AS RNUM, E.* 
        FROM (SELECT * FROM EMPLOYEES ORDER BY HIRE_DATE ASC) E WHERE ROWNUM <= 40 )
WHERE RNUM >= 31;










