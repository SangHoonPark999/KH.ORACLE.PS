--EMPLOYEES 이름과 직급을 출력하시오. [ELLEN 님의 직급은 매니저 입니다.]
SELECT first_name ||'님의 직급은'|| JOB_ID || '입니다.' AS MESSAGE FROM EMPLOYEES;
--EMPLOYEES 직급을 중복하지말고 출력하시오.
SELECT DISTINCT JOB_ID FROM employees;
SELECT JOB_ID, COUNT(*) 직급별카운트 FROM employees GROUP BY JOB_ID HAVING COUNT(*) >=20 ;
--NULL은 비교대상이 되지 않는다
SELECT EMLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;
--직급을 기준으로 내림차순 정렬, 연봉은 오름차순 2차 정렬 이상 처리된다.
SELECT JOB_ID, SALARY FROM EMPLOYEES ORDER BY JOB_ID DESC, SALARY ASC;


--가상테이블 => 진짜 테이블(인스턴스가 1개, 컬럼명 1개 있는 테이블)
SELECT 24+NULL+34 AS RESULT FROM departments;
DESC DUAL;
SELECT 24+35 AS RESULT FROM DUAL;

--GROUP BY : 2개이상이 나와야 그룹의 대상이 된다.
--부서별 총 급여를 구하시오.
--SELECT * FROM GROUP BY HAVING WHERE ORDER BY (ASC/DESC) LIMIT
SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID HAVING SUM(SALARY) >= 50000 AND DEPARTMENT_ID =100;
SELECT * FROM EMPLOYEES;
--
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID FROM employees
WHERE JOB_ID = UPPER('it_prog');
--CONCAT(인수가 2개만 허용된다.)
SELECT CONCAT(FIRST_NAME, '($'||SALARY||')') AS "사원정보" FROM EMPLOYEES
WHERE department_id = 30;
SELECT CONCAT(FIRST_NAME, '($',SALARY,')') AS "사원 정보" FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

SELECT FIRST_NAME, SUBSTR(HIRE_DATE,4,2)
FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--현재 날짜를 출력
SELECT SYSDATE FROM DUAL;
--EMPLOYEES에서 사원의 입사년도부터 현재까지 근무 개월수 올림 반올림등(TRUNC, ROUND)
SELECT FIRST_NAME, SYSDATE, TO_CHAR(HIRE_DATE,'YYYY/MM/DD') 입사일,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;

--현제날짜에 '2024/04/24' 날짜를 뺴서 계산
SELECT SYSDATE-'2024/04/24' FROM DUAL;
SELECT SYSDATE- TO_DATE('2024/04/24','YYYY,MM,DD') FROM DUAL;
--문자열 + 문자열 => 오류
SELECT CONCAT('10000','20000') FROM DUAL;
SELECT TO_NUMBER('10,000','999,999') + TO_NUMBER('20,000','999,999') AS "합산" FROM DUAL;
-- EMPLOYEES 에서 직급별 정렬(오름차순), 이름, 봉급, 인상률, 보너스금액, 월급 + 보너스 금액
SELECT FIRST_NAME, SALARY, NVL(COMMISSION_PCT,0), SALARY*NVL(COMMISSION_PCT,0) AS COMMISSION, SALARY+(NVL(COMMISSION_PCT,0)) AS TOTAL
, JOB_ID FROM EMPLOYEES ORDER BY JOB_ID;
--NVL2(컬럼,  NULL이 아니면, NULL)
SELECT FIRST_NAME, SALARY, COMMISSION_PCT,
NVL2(COMMISSION_PCT,SALARY+(NVL(COMMISSION_PCT), SALARY) TOTAL_SAL FROM EMPLOYEES;
--SWITCH->DECODE
SELECT DEPARTMENT_ID,
DECODE(DEPARTMENT_ID,
10, 'Administration',
20, 'Marketing',
30, 'Purchasing',
40, 'Human Resources',
50, 'Shipping',
60, 'IT',
'DEFAULT' ) AS DEPARTMENTS FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

--GROUP BY SUM, AVG, MAX, MIN, COUNT
--COUNT(*) NULL 값은 인정하지 않는다.
SELECT COUNT(*) AS TOTAL FROM EMPLOYEES;
SELECT COUNT(SALARY) AS TOTAL FROM EMPLOYEES;
--부서별로 월급 평균을 구하시오
SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS "부서별 평균 연봉", MAX(SALARY), MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
--EMPLOYEES 에서 부서별로 최대급여, 최소급여를 보여주되, 부서별 정렬(ASC)
SELECT DEPARTMENT_ID,MAX(SALARY),MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID ORDER BY DEPARTMENT_ID;
--ROLLUP은 GROUP BY를 부분 항목별로 통계를 해줄것이다
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID,JOB_ID;
--CUBE ROLLUP 합계
SELECT DEPARTMENT_ID,JOB_ID, MAX(SALARY),MIN(SALARY),COUNT(*),TRUNC(AVG(SALARY)),SUM(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID,JOB_ID)
ORDER BY DEPARTMENT_ID;

--새로운 테이블 만들기 DEPT 속성(DEPTNO, DNAME, LOC) NOT NULL(모두), PK (DEPTNO)
CREATE TABLE DEPT(
    DEPTNO NUMBER(4),
    DNAME VARCHAR2(20) NOT NULL,
    LOC VARCHAR2(20) 
);
--PK생성
ALTER TABLE DEPT ADD CONSTRAINT DEPT_PK PRIMARY KEY(DEPTNO);
--PK드랍
ALTER TABLE DEPT DROP CONSTRAINT DEPT_PK;
ALTER TABLE DEPT MODIFY DNAME VARCHAR2(20);
ALTER TABLE DEPT ADD DPHONE VARCHAR2(12);
ALTER TABLE DEPT DROP COLUMN DPHONE;
ALTER TABLE DEPT DROP COLUMN LOC;
ALTER TABLE DEPT ADD LOC VARCHAR2(20) NULL;
--INSERT
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(1,'컴푸터학과','본관');
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(2,'시수템학과','공학관');
INSERT INTO DEPT VALUES(3,'컴공','공학관2');
INSERT INTO DEPT(DEPTNO, DNAME) VALUES(4,'디자인');
INSERT INTO DEPT VALUES(5,'컴디',NULL);
--SELECT
SELECT * FROM DEPT;
DESC DEPT;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
DROP TABLE DEPT;
SELECT * FROM DEPARTMENTS;
--기존의 테이블에 데이터만 다른 테이블에 있는 내용을 가져오고 싶을떄
INSERT INTO DEPT
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS;

SELECT * FROM DEPT;

UPDATE INTO table_name
SET column_name1 = value1, column_name2 = value2
WHERE conditions;

--새로운 테이블을 만들다 (개념적-논리적-물리적 설계 후 INSERT INTO 테이블명(컬럼명) VALUES() WHERE(없음)) 50번 반복
--다른 테이블에 이러한 구조가 있는데 수정, 삽입, 삭제 빈번히 일어나야 되는데 원본을 회손시키고 싶지 않을 때 사용
--제약조건은 복사를 못한다.(ALTER TABLE을 사용해 제약조건을 넣어준다.)
CREATE TABLE EMP
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP;
DESC EMP;
-- EMP EMPLOYEE_ID PK 지정
ALTER TABLE EMP ADD CONSTRAINT EMPLOYEE_PK PRIMARY KEY(EMPLOYEE_ID);

--EMP 부서번호 90 => 91번으로 변경
UPDATE EMP SET DEPARTMENT_ID = 91; --X
ROLLBACK;
UPDATE EMP SET DEPARTMENT_ID = 91 WHERE DEPARTMENT_ID = 90;
COMMIT;
--EMP에서 부서 91만 SALARY 10%인상
UPDATE EMP SET SALARY = ROUND(SALARY*1.1) WHERE DEPARTMENT_ID = 91;
SELECT * FROM EMP WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP 에서 사원이름 SUSAN 사람의 부서를 20, 직급 FI_MGR
UPDATE EMP SET DEPARTMENT_ID = 20, JOB_ID = 'FI_MGR' WHERE UPPER(FIRST_NAME) = 'SUSAN';
--EMP에서 부서 20번 직원만 삭제
DELETE FROM EMP WHERE DEPARTMENT_ID = 20;

--ROWID, ROWNIM 테이블의 행, ROW, INSTANCE, TUPLE 라인 번호를 자동설정한다
SELECT * FROM EMPLOYEES WHERE ROWNUM <= 3;
SELECT ROWID FROM EMPLOYEES;
SELECT ROWNUM FROM EMPLOYEES;
--TAB : TABLE 각 데이터베이스마냥 테이블 내용을 보고싶으면 TAB 조사하면 된다.
SELECT *FROM TAB;
--테이블 복사 : EMPLOYEES2 : EMPLOYEES (NOT NULL 제약조건)
--PK, UK, CHECK, FK(무결성제약조건 복사 이루어진다)
CREATE TABLE EMPLOYEES2
AS
SELECT * FROM EMPLOYEES;
DESC EMPLOYEES2;
--AGE 숫자 3 까지만 인정, 체크제약조건 0<나이<150
ALTER TABLE EMPLOYEES2
ADD AGE NUMBER(3) CHECK (AGE BETWEEN 0 AND 150);
--AGE 숫자 4 까지 증가
ALTER TABLE EMPLOYEES2 MODIFY AGE NUMBER(4);
--AGE 를 삭제해보세요
ALTER TABLE EMPLOYEES2 DROP COLUMN AGE;
-- FIRST_NAME VARCHAR2(20)=> VARCHAR2(10)
ALTER TABLE EMPLOYEES2 MODIFY FIRST_NAME VARCHAR2(22);
--EMPLOYEES2 테이블 삭제하고 ROLLBACK을 사용하지 않고 복구하는 방법
DROP TABLE EMPLOYEES2;
SELECT * FROM TAB;
--휴지통 구조
DESC RECYCLEBIN;
SELECT * FROM RECYCLEBIN;
--휴지통으로 복구
FLASHBACK TABLE EMPLOYEES2 TO BEFORE DROP;
--휴지통 비우기
PURGE RECYCLEBIN;

--컬럼사이즈를 줄여서 복사하는 방법
DROP TABLE TESTA;
CREATE TABLE TESTA(
    NAME CHAR(20) NOT NULL,
    AGE NUMBER(3) NOT NULL
);
INSERT INTO TESTA VALUES('1234567890',34);
INSERT INTO TESTA VALUES('12345678',60);
SELECT * FROM TESTA;
CREATE TABLE TESTB(
    NAME2 CHAR(10) NOT NULL,
    AGE2 NUMBER(3) NOT NULL
);
DESC TESTB;

INSERT INTO TESTB(NAME2,AGE2)
SELECT SUBSTR(NAME,1,10), AGE FROM TESTA;

SELECT * FROM DEPARTMENTS;
--테이블 명을 변경하는 방법
SELECT *FROM TAB;
RENAME EMLOYEES2 TO EMPLOYEES4;


--테이블 설계한다. (EMO01, 번호, 직업, 부서) 제약조건은 NULL 허용
CREATE TABLE EMP02(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10),
    DEP_ID VARCHAR2(10)
);
INSERT INTO EMP02 VALUES (10, 'JDK','IT_TEACHER','NULL');
SELECT * FROM EMP02;
--DEP_ID NOT NULL 제약조건
TRUNCATE TABLE EMP02;
ALTER TABLE EMP02 MODIFY DEP_ID VARCHAR(10) NOT NULL;

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP02';

INSERT INTO EMP02(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
INSERT INTO EMP02 VALUES (12, 'KKK', 'ITDEV','LG');
--UNIQUE 제약조건을 줄것 (EMP_NAME)
DROP TABLE EMP05;
CREATE TABLE EMP05(
    EMP_NO NUMBER(10),
    EMP_NAME VARCHAR2(10),
    EMP_JOB VARCHAR2(10) DEFAULT 'BACKEND',
    DEP_ID VARCHAR2(10)
);
ALTER TABLE EMP05 ADD CONSTRAINT EMP05_UK UNIQUE(EMP_NAME); 

ALTER TABLE EMP05
DROP CONSTRAINT SYS_C008426;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP05';
--UNIQUE 제약조건에 위배되는 조건
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (11, 'KHY', 'ITDEV','구글');
SELECT * FROM EMP05;
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (12, NULL, 'ITDEV','구글');
INSERT INTO EMP05(EMP_NO, EMP_NAME, EMP_JOB, DEP_ID) VALUES (13, NULL, 'ITDEV','구글');

--데이터 DICTIONARY (USER, ALL, DBA) 제약조건 구조와 
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_TABLES WHERE TABLE_NAME = 'EMPLOYEES';

-- DEPT1 테이블 생성 및 데이터 입력
-- 부모테이블에서 참조된 기본키 값을 변경하거나 삭제를 진행 할 때는
-- 자식테이블에 참조키를 NULL 수정하거나, 해당된 튜플을 삭제하면 된다.
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    CONSTRAINT DEPT01_PK PRIMARY KEY(DEPTNO)
);
INSERT INTO DEPT01 VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT01 VALUES(20,'RESEARCH','DALLAS');
INSERT INTO DEPT01 VALUES(30,'DEVELOPMENT','KOREA');
SELECT * FROM DEPT01;
DELETE FROM DEPT01 WHERE DEPTNO = 10;
UPDATE DEPT01 SET DEPTNO = 40 WHERE DEPTNO = 10;


--EMP01 테이블 생성 및 데이터 입력 UPDATE 할 때 없는 부모키를 참조하면 오류가 나올때를
--제외하면 문제가 없다 
CREATE TABLE EMP01(
    EMPNO NUMBER(4), --제약조건1(PK)
    ENAME VARCHAR2(10) NOT NULL, --제약조건2(NN)
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4), --제약조건3(FK) : 참조테이블 주의 UPDATE, DELETE
    PRIMARY KEY(EMPNO),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
);
INSERT INTO EMP01 VALUES(7499, 'ALLEN', 'SALESMAN', 10);
INSERT INTO EMP01 VALUES(7369, 'SMITH', 'CLERK', 20); 
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';
ALTER TABLE EMP01 DROP CONSTRAINT SYS_C008446;
ALTER TABLE EMP01
ADD CONSTRAINT EMP01_DEPT01_DEPTNO_FK
FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO) ON DELETE CASCADE; 

SELECT * FROM EMP01;
DELETE FROM EMP01 WHERE EMPNO = 7499;
UPDATE EMP01 SET DEPTNO = 10 WHERE EMPNO = 7369;
DELETE FROM EMP01;
SELECT *FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';

--CROSS JOIN (가로로 생성)
SELECT * FROM EMPLOYEES; --107
SELECT * FROM DEPARTMENTS; --27
SELECT COUNT(*) FROM EMPLOYEES, DEPARTMENTS; --2889
-- CROSS JOIN (ANSI CROSS JOIN))
SELECT COUNT(*) FROM EMPLOYEES CROSS JOIN DEPARTMENTS; --2889

-- INNER JOIN (PK:부모,참조 = FK:자식,기본,주)
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI INNER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');
-- INNER JOIN (ANSI INNER JOIN USING) 기본키와 참조키의 속성명이 같을 경우
-- ON을 사용하지 말것, 별칭은 사용하되, USING으로 사용된 속성명에는 별칭을 붙이지 않는다.
SELECT E.FIRST_NAME, DEPARTMENT_ID, D.DEPARTMENT_NAME FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
USING(DEPARTMENT_ID)
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');

--NON EQUA JOIN 은 PK,FK가 없기에 '=' 연산자는 사용하지 않는다. 
CREATE TABLE SALARYGRADE (
    GRADE NUMBER,
    MINSALARY NUMBER,
    MAXSALARY NUMBER
);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(1, 2000, 3000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(2, 3001, 4500);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(3, 4501, 6000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(4, 6001, 8000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(5, 8001, 10000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(6, 10001, 13000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(7, 13001, 20000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(8, 20001, 30000);

SELECT E.FIRST_NAME, E.SALARY, S.GRADE 등급 FROM EMPLOYEES E, SALARYGRADE S
WHERE E.SALARY BETWEEN S.MINSALARY AND S.MAXSALARY;

--OUTER JOIN = INNER JOIN (PK, FK) = LEFT OUTER JOIN, RIGHT OUTER JOIN, BOTH OUTER JOIN
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
--OUTER JOIN (ANSI OUTER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--OUTER JOIN (ANSI OUTER JOIN)
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

--2007년도 상반기에 입사한 사원을 조사해라.
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
AND (HIRE_DATE BETWEEN '2007.01.01' AND '2007.06.30');

--SELF JOIN (한개의 테이블을 두개 테이블로 만들어 조인한다)PK, 선언 되지 않는 FK 생각할것
SELECT * FROM EMPLOYEES;
SELECT E2.EMPLOYEE_ID, E2.FIRST_NAME 사원이름, E2.SALARY 사원월급, E1.EMPLOYEE_ID 상사아이디, E1.FIRST_NAME 상사이름, E1.SALARY 상사월급
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

SELECT E2.FIRST_NAME || '사원의 상사 이름은' || E1.FIRST_NAME || '입니다.'
FROM EMPLOYEES E1, EMPLOYEES E2
WHERE E1.EMPLOYEE_ID = E2.MANAGER_ID;

--ROWNUM(번호가 자동설정진행) 10개만 보고 싶다.
SELECT * FROM EMPLOYEES WHERE ROWRUM<=10;
--SALARY 제일 많이 받는 사람순으로 10명만 출력
--연산의 순서가 다르기 때문에 서브쿼리를 사용하여 구한다.
SELECT * FROM EMPLOYEES ORDER BY SALARY DESC;
SELECT FIRST_NAME, SALARY FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC) WHERE ROWNUM <= 10;
--SUSAN 사원이 해당되는 사원의 사람이름, 부서번호, 부서명을 출력하시오
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE UPPER(E.FIRST_NAME) = UPPER('SUSAN');

--SUSAN, LEX 두사람의 급여 출력
SELECT FIRST_NAME, SALARY 
FROM EMPLOYEES 
WHERE FIRST_NAME IN ('Susan', 'Lex');
--EMPLOYEES 테이블에서 Susan 또는 Lex와 월급이 같은 직원의 이름, 업무, 급여를 출력하는 SELECT문을 
--작성하시오. (Susan, Lex는 제외) 
SELECT FIRST_NAME, JOB_ID, SALARY 
FROM EMPLOYEES 
WHERE SALARY IN (
    SELECT FIRST_NAME, SALARY 
    FROM EMPLOYEES 
    WHERE FIRST_NAME IN ('Susan', 'Lex'))
AND NOT UPPER(FIRST_NAME) IN ('SUSAN','LEX'); 

--30번 소속 직원들 중에서 급여를 가장 많이 받은 사원 보다 더 많은 급여를 받는 사람의 이름, 급여 
--를 출력하는 쿼리문  작성
SELECT MAX(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 30);

DROP TABLE EMP03;

CREATE TABLE EMP03
AS
SELECT * FROM EMPLOYEES WHERE 1 = 0;
SELECT * FROM EMP03;
DESC EMP03;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP03';
--DEPARTMENTS 구좀나 복사 DEPT01 => 내용을 추가한다.
DROP TABLE DEPT01 CASCADE CONSTRAINTS;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPARTMENTS
WHERE 1 = 0;
SELECT * FROM DEPT01;
INSERT INTO DEPT01 (SELECT * FROM DEPARTMENTS);

--10번 부서의 지역번호(1700)을 40번 부서의 지역번호(2400)으로 변경하기 위해서 서브 쿼리을 사용해본다.
SELECT * FROM DEPT01 WHERE DEPARTMENT_ID = 10;
SELECT * FROM DEPT01 WHERE DEPARTMENT_ID = 40;
UPDATE DEPT01 SET LOCATION_ID = 1700 WHERE DEPARTMENT_ID = 10;
UPDATE DEPT01 SET LOCATION_ID = (SELECT LOCATION_ID FROM DEPT01 WHERE DEPARTMENT_ID = 10) WHERE DEPARTMENT_ID = 40;

--TRANSATION TESTING
COMMIT; --트랜잭션이 끝남과 동시에 새로 트랜잭션이 새로 시작함.
DROP TABLE DEPT02;
CREATE TABLE DEPT02 --ROLLBACK 복구지점
AS
SELECT * FROM DEPARTMENTS;
SELECT * FROM DEPT02;
DELETE FROM DEPT02; --DROP, TRUNCATE, DELETE 차이점
SELECT * FROM DEPT02;
ROLLBACK;
SELECT * FROM DEPT02;
DELETE FROM DEPT02 WHERE DEPARTMENT_ID = 20;
SELECT * FROM DEPT02;
COMMIT; --
ROLLBACK;
SELECT * FROM DEPT02;

--VIEW
--VEIW IMP01 -VIEW 만들다 실제테이블(사원), 가상주체(사원아이다. 사원이름, 부서아이디)






